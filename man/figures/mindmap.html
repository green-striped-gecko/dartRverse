<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Groups Mind Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --panel-bg: #f5f5f5;
            --border-color: #dddddd;
            --highlight-color: #2a76dd;
            --link-color: #999999;
            --search-bg: #ffffff;
            --tooltip-bg: rgba(255, 255, 255, 0.95);
            --tooltip-border: #cccccc;
            --sidebar-bg: #f5f5f5;
            --sidebar-header: #e0e0e0;
            --toggle-bg: #f0f0f0;
            --toggle-slider: #2a76dd;
        }

        .dark-mode {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --panel-bg: #2d2d2d;
            --border-color: #444444;
            --highlight-color: #5a9eff;
            --link-color: #777777;
            --search-bg: #333333;
            --tooltip-bg: rgba(45, 45, 45, 0.95);
            --tooltip-border: #555555;
            --sidebar-bg: #2d2d2d;
            --sidebar-header: #3d3d3d;
            --toggle-bg: #444444;
            --toggle-slider: #5a9eff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .link {
            fill: none;
            stroke: var(--link-color);
            stroke-width: 1.5px;
            opacity: 0.7;
            transition: opacity 0.3s ease, stroke-width 0.3s ease;
        }

        .link:hover {
            opacity: 1;
            stroke-width: 2.5px;
        }

        .node {
            cursor: pointer;
        }

        .node text {
            font-size: 12px;
            fill: var(--text-color);
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            transition: fill 0.3s ease;
        }

        .root-node text {
            font-size: 14px;
            font-weight: bold;
        }

        .group-node text {
            font-size: 13px;
            font-weight: bold;
        }

        .function-node text {
            font-size: 11px;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .search-container {
            position: relative;
        }

        #search {
            width: 200px;
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--search-bg);
            color: var(--text-color);
            outline: none;
            transition: all 0.3s ease;
        }

        #search:focus {
            border-color: var(--highlight-color);
            box-shadow: 0 0 0 2px rgba(42, 118, 221, 0.2);
        }

        .clear-search {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-color);
            opacity: 0.6;
            font-size: 14px;
            display: none;
        }

        .clear-search:hover {
            opacity: 1;
        }

        .filter-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .filter-options {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .filter-option {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .filter-option input {
            margin-right: 8px;
        }

        .filter-option label {
            font-size: 13px;
            user-select: none;
        }

        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        .mode-toggle-label {
            font-size: 13px;
            user-select: none;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--toggle-bg);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--toggle-slider);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .tooltip {
            position: absolute;
            background-color: var(--tooltip-bg);
            border: 1px solid var(--tooltip-border);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            pointer-events: none;
            opacity: 0;
            max-width: 300px;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .tooltip h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tooltip p {
            margin: 5px 0;
        }

        .sidebar {
            position: absolute;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background-color: var(--sidebar-bg);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            transition: right 0.3s ease;
            z-index: 200;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
        }

        .sidebar.active {
            right: 0;
        }

        .sidebar-header {
            padding: 15px;
            background-color: var(--sidebar-header);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-title {
            margin: 0;
            font-size: 18px;
        }

        .sidebar-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-color);
        }

        .sidebar-content {
            padding: 15px;
        }

        .function-title {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 20px;
            font-weight: bold;
        }

        .function-group {
            margin-bottom: 10px;
            font-size: 16px;
            color: var(--highlight-color);
        }

        .function-description {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .function-details {
            margin-top: 20px;
        }

        .detail-item {
            margin-bottom: 15px;
        }

        .detail-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .helper-text {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 13px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            max-width: 250px;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .legend-text {
            font-size: 12px;
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: var(--highlight-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .controls {
                top: 10px;
                left: 10px;
                padding: 10px;
            }

            #search {
                width: 180px;
            }

            .sidebar {
                width: 280px;
            }

            .helper-text, .legend {
                display: none;
            }
        }

        .placeholder-logo {
            fill: var(--highlight-color);
        }

        .placeholder-logo-text {
            fill: white;
            font-size: 24px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--highlight-color);
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Loading screen -->
        <div class="loading">
            <div class="spinner"></div>
        </div>

        <!-- Controls panel -->
        <div class="controls">
            <div class="search-container">
                <input type="text" id="search" placeholder="Search functions...">
                <button class="clear-search">×</button>
            </div>
            <div class="filter-container">
                <div class="filter-title">Filter Function Groups</div>
                <div class="filter-options" id="filter-options">
                    <!-- Filter checkboxes will be added dynamically -->
                </div>
            </div>
            <div class="mode-toggle">
                <span class="mode-toggle-label">Dark Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="dark-mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <!-- Helper text -->
        <div class="helper-text">
            <strong>Controls:</strong> Click to expand/collapse groups • Drag to reposition • Scroll to zoom • Click function for details
        </div>

        <!-- Legend -->
        <div class="legend">
            <div class="legend-title">Function Groups</div>
            <div id="legend-items">
                <!-- Legend items will be added dynamically -->
            </div>
        </div>

        <!-- Visualization container -->
        <svg id="mindmap"></svg>

        <!-- Tooltip -->
        <div class="tooltip" id="tooltip"></div>

        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h3 class="sidebar-title">Function Details</h3>
                <button class="sidebar-close">&times;</button>
            </div>
            <div class="sidebar-content" id="sidebar-content">
                <!-- Function details will be added dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Data parsing and visualization
        (function() {
            // Parse CSV data
            const csvData = `Function Group,Function Name
Environment Setup,dartRverse_install
Environment Setup,gl.check.verbosity
Environment Setup,gl.check.wd
Environment Setup,gl.colors
Environment Setup,gl.download.binary
Environment Setup,gl.print.history
Environment Setup,gl.select.colors
Environment Setup,gl.select.panel
Environment Setup,gl.select.shapes
Environment Setup,gl.set.verbosity
Environment Setup,gl.set.wd
Input,gl.add.indmetrics
Input,gl.compliance.check
Input,gl.load
Input,gl.read.csv
Input,gl.read.dart
Input,gl.read.fasta
Input,gl.read.PLINK
Input,gl.read.silicodart
Input,gl.read.vcf
Data Refinement,gl.blast
Data Manipulation ,gl.define.pop
Data Manipulation ,gl.drop.ind
Data Manipulation ,gl.drop.loc
Data Manipulation ,gl.drop.pop
Data Manipulation ,gl.edit.recode.ind
Data Manipulation ,gl.edit.recode.pop
Data Refinement,gl.impute
Data Manipulation ,gl.join
Data Manipulation ,gl.keep.ind
Data Manipulation ,gl.keep.loc
Data Manipulation ,gl.keep.pop
Data Manipulation ,gl.make.recode.ind
Data Manipulation ,gl.make.recode.pop
Data Manipulation ,gl.merge.pop
Data Refinement,gl.random.snp
Data Manipulation ,gl.recode.ind
Data Manipulation ,gl.recode.pop
Data Manipulation ,gl.rename.pop
Data Manipulation ,gl.sample
Data Manipulation ,gl.save
Data Manipulation ,gl.sort
Data Manipulation ,gl.subsample.ind
Data Manipulation ,gl.subsample.loc
Reports,gl.report.allna
Reports,gl.report.callrate
Reports,gl.report.excess.het
Reports,gl.report.factorloadings
Reports,gl.report.hamming
Reports,gl.report.heterozygosity
Reports,gl.report.hwe
Reports,gl.report.ld.map
Reports,gl.report.locmetric
Reports,gl.report.maf
Reports,gl.report.monomorphs
Reports,gl.report.overshoot
Reports,gl.report.pa
Reports,gl.report.parent.offspring
Reports,gl.report.rdepth
Reports,gl.report.reproducibility
Reports,gl.report.secondaries
Reports,gl.report.taglength
Filters,gl.filter.allna
Filters,gl.filter.callrate
Filters,gl.filter.excess.het
Filters,gl.filter.factorloadings
Filters,gl.filter.hamming
Filters,gl.filter.heterozygosity
Filters,gl.filter.hwe
Filters,gl.filter.ld
Filters,gl.filter.locmetric
Filters,gl.filter.maf
Filters,gl.filter.monomorphs
Filters,gl.filter.overshoot
Filters,gl.filter.pa
Filters,gl.filter.parent.offspring
Filters,gl.filter.rdepth
Filters,gl.filter.reproducibility
Filters,gl.filter.secondaries
Filters,gl.filter.taglength
Filters,gl.recalc.metrics
Exploration and visualisation,gl.map.interactive
Exploration and visualisation,gl.pcoa
Exploration and visualisation,gl.pcoa.plot
Exploration and visualisation,gl.report.basics
Exploration and visualisation,gl.smearplot
Genetic Structure,gl.evanno
Genetic Structure,gl.map.popcluster
Genetic Structure,gl.map.snmf
Genetic Structure,gl.map.structure
Genetic Structure,gl.pcoa
Genetic Structure,gl.pcoa.plot
Genetic Structure,gl.plot.faststructure
Genetic Structure,gl.plot.popcluster
Genetic Structure,gl.plot.snmf
Genetic Structure,gl.plot.structure
Genetic Structure,gl.run.faststructure
Genetic Structure,gl.run.popcluster
Genetic Structure,gl.run.snmf
Genetic Structure,gl.run.structure
Genetic Variation,gl.alf
Genetic Variation,gl.allele.freq
Genetic Variation,gl.diagnostics.hwe
Genetic Variation,gl.He
Genetic Variation,gl.Ho
Genetic Variation,gl.hwe.pop
Genetic Variation,gl.report.allelerich
Genetic Variation,gl.report.bases
Genetic Variation,gl.report.diversity
Genetic Variation,gl.report.heterozygosity
Genetic Variation,gl.report.hwe
Genetic Variation,gl.report.hwe
Genetic Variation,gl.report.nall
Genetic Variation,gl.report.polyploid_heterozygosity
Genetic Variation,gl.report.shannon
Genetic Variation,gl.sfs
Genetic Variation,gl.test.heterozygosity
Genetic Differentiation,gl.amova
Genetic Differentiation,gl.dist.ind
Genetic Differentiation,gl.dist.pop
Genetic Differentiation,gl.fst.pop
Genetic Differentiation,gl.kosman
Genetic Differentiation,gl.plot.heatmap
Genetic Differentiation,gl.report.fstat
Genetic Differentiation,gl.report.pa
Gene Flow/Spatial,gl.costdistances
Gene Flow/Spatial,gl.genleastcost
Gene Flow/Spatial,gl.ibd
Gene Flow/Spatial,gl.run.eems
Gene Flow/Spatial,gl.spatial.autoCorr
Relatedness,gl.filter.parent.offspring
Relatedness,gl.grm
Relatedness,gl.grm.network
Relatedness,gl.grm2
Relatedness,gl.plot.heatmap
Relatedness,gl.plot.network
Relatedness,gl.propShared
Relatedness,gl.report.parent.offspring
Relatedness,gl.run.colony
Relatedness,gl.run.EMIBD9
Population Size,gl.LDNe
Population Size,gl.run.epos
Population Size,gl.run.stairway2
Population Size,gl.sfs
Population Assignment ,gl.assign.grm
Population Assignment ,gl.assign.mahalanobis
Population Assignment ,gl.assign.pa
Population Assignment ,gl.assign.pca
Population Assignment ,gl.mahal.assign
Linkage Disequilibrium,gl.filter.ld
Linkage Disequilibrium,gl.ld.distance
Linkage Disequilibrium,gl.ld.haplotype
Linkage Disequilibrium,gl.report.ld.map
Natural Selection,gl.outflank
Natural Selection,gl.TajimasD
Phylogenetics,gl.collapse
Phylogenetics,gl.dist.phylo
Phylogenetics,gl.fdsim
Phylogenetics,gl.fixed.diff
Phylogenetics,gl.nhybrids
Phylogenetics,gl.report.pa
Phylogenetics,gl.tree.fitch
Phylogenetics,gl.tree.nj
Sex-linked,gl.drop.sexlinked
Sex-linked,gl.infer.sex
Sex-linked,gl.keep.sexlinked
Sex-linked,gl.report.sexlinked
Simulations,gl.diagnostics.sim
Simulations,gl.sim.create.dispersal
Simulations,gl.sim.crosses
Simulations,gl.sim.emigration
Simulations,gl.sim.genotypes
Simulations,gl.sim.ind
Simulations,gl.sim.mutate
Simulations,gl.sim.offspring
Simulations,gl.sim.relatedness
Simulations,gl.sim.WF.run
Simulations,gl.sim.WF.table
Export,gi2gl
Export,gl.write.csv
Export,gl2bayesAss
Export,gl2bayescan
Export,gl2bpp
Export,gl2colony
Export,gl2demerelate
Export,gl2eigenstrat
Export,gl2fasta
Export,gl2faststructure
Export,gl2gapit
Export,gl2gds
Export,gl2genalex
Export,gl2genepop
Export,gl2geno
Export,gl2gi
Export,gl2hapmap
Export,gl2hiphop
Export,gl2paup.parsimony
Export,gl2paup.svdquartets
Export,gl2phylip
Export,gl2structure
Export,gl2treemix
Export,gl2vcf
Genlight Accessors,chromosome
Genlight Accessors,indNames
Genlight Accessors,locNames
Genlight Accessors,nInd
Genlight Accessors,nLoc
Genlight Accessors,nPop
Genlight Accessors,pop
Genlight Accessors,popNames
Genlight Accessors,position`;

            // Function to parse CSV data
            function parseCSV(csvString) {
                // Split by newlines and remove empty rows
                const rows = csvString.split('\n').filter(row => row.trim().length > 0);
                
                // Get headers
                const headers = rows[0].split(',').map(header => header.trim());
                
                // Parse data rows
                const data = rows.slice(1).map(row => {
                    const values = row.split(',').map(value => value.trim());
                    const rowData = {};
                    headers.forEach((header, index) => {
                        rowData[header] = values[index];
                    });
                    return rowData;
                });
                
                return data;
            }

            // Process the CSV data
            const parsedData = parseCSV(csvData);
            
            // Group functions by their group
            const groupedFunctions = {};
            
            parsedData.forEach(item => {
                const group = item['Function Group'];
                const functionName = item['Function Name'];
                
                if (!groupedFunctions[group]) {
                    groupedFunctions[group] = [];
                }
                
                groupedFunctions[group].push({
                    name: functionName,
                    // Mock descriptions and details for demonstration
                    description: `This is a description for ${functionName} in the ${group} group.`,
                    parameters: ["param1", "param2"],
                    returnType: "Return type",
                    example: `${functionName}(param1, param2)`
                });
            });
            
            // Define a D3 color scheme
            const baseColors = [
                "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", 
                "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
                "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5",
                "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"
            ];
            
            // Create hierarchical data structure for D3
            const hierarchyData = {
                name: "Function Groups",
                children: Object.keys(groupedFunctions).map((group, index) => {
                    return {
                        name: group,
                        color: baseColors[index % baseColors.length],
                        collapsed: true, // Start with collapsed groups
                        children: groupedFunctions[group].map(func => {
                            return {
                                name: func.name,
                                description: func.description,
                                parameters: func.parameters,
                                returnType: func.returnType,
                                example: func.example,
                                group: group,
                                isFunction: true
                            };
                        })
                    };
                })
            };
            
            // Variables for the visualization
            let svg, link, node, simulation;
            let width, height;
            let currentTransform = d3.zoomIdentity;
            let nodes = [], links = [];
            let tooltip, sidebar;
            let searchTimeout;
            let activeFilters = [];
            
            // Initialize visualization
            function initVisualization() {
                // Set dimensions
                width = window.innerWidth;
                height = window.innerHeight;
                
                // Get DOM elements
                svg = d3.select("#mindmap");
                tooltip = d3.select("#tooltip");
                sidebar = d3.select("#sidebar");
                
                // Setup SVG
                svg.attr("width", width)
                   .attr("height", height);
                
                // Create zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on("zoom", (event) => {
                        currentTransform = event.transform;
                        d3.select("svg g").attr("transform", event.transform);
                    });
                
                svg.call(zoom);
                
                // Reset zoom to center
                svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2));
                
                // Create container for nodes and links
                const container = svg.append("g")
                    .attr("transform", `translate(${width / 2}, ${height / 2})`);
                
                // Create groups for links and nodes (order matters for layering)
                container.append("g").attr("class", "links");
                container.append("g").attr("class", "nodes");
                
                // Setup force simulation
                simulation = d3.forceSimulation()
                    .force("link", d3.forceLink().id(d => d.id).distance(d => {
                        // Different distances based on node types
                        if (d.source.depth === 0 && d.target.depth === 1) {
                            return 150; // Root to group
                        } else {
                            return 100; // Group to function
                        }
                    }).strength(1))
                    .force("charge", d3.forceManyBody().strength(d => {
                        // Different charges based on node types
                        if (d.depth === 0) return -2000; // Root node
                        if (d.depth === 1) return -1000; // Group nodes
                        return -300; // Function nodes
                    }))
                    .force("collide", d3.forceCollide().radius(d => {
                        // Different collision radii based on node types
                        if (d.depth === 0) return 100; // Root node
                        if (d.depth === 1) return 60; // Group nodes
                        return 40; // Function nodes
                    }))
                    .force("x", d3.forceX(0).strength(0.05))
                    .force("y", d3.forceY(0).strength(0.05))
                    .on("tick", ticked);
                
                // Initialize with root node and its direct children
                updateVisualization(hierarchyData);
                
                // Initialize search functionality
                initSearch();
                
                // Initialize filter options
                initFilters();
                
                // Initialize legend
                initLegend();
                
                // Initialize sidebar close button
                d3.select(".sidebar-close").on("click", () => {
                    sidebar.classed("active", false);
                });
                
                // Initialize dark mode toggle
                initDarkMode();
                
                // Hide loading screen after initialization
                setTimeout(() => {
                    d3.select(".loading").style("opacity", 0).remove();
                }, 1000);
            }
            
            // Update the visualization with new data
            function updateVisualization(rootNode) {
                // Prepare the data
                const root = d3.hierarchy(rootNode);
                
                // Process the data to create visible nodes and links
                processHierarchy(root);
                
                // Update the links
                link = d3.select("svg g.links")
                    .selectAll("path")
                    .data(links, d => `${d.source.id}-${d.target.id}`);
                
                // Remove old links
                link.exit().transition().duration(300)
                    .attr("stroke-opacity", 0)
                    .remove();
                
                // Add new links
                const linkEnter = link.enter()
                    .append("path")
                    .attr("class", "link")
                    .attr("stroke-opacity", 0)
                    .attr("d", d => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });
                
                // Merge links
                link = linkEnter.merge(link)
                    .transition()
                    .duration(300)
                    .attr("stroke-opacity", 1);
                
                // Update the nodes
                node = d3.select("svg g.nodes")
                    .selectAll("g.node")
                    .data(nodes, d => d.id);
                
                // Remove old nodes
                node.exit().transition().duration(300)
                    .attr("opacity", 0)
                    .remove();
                
                // Add new nodes
                const nodeEnter = node.enter()
                    .append("g")
                    .attr("class", d => {
                        let classes = "node";
                        if (d.depth === 0) classes += " root-node";
                        else if (d.depth === 1) classes += " group-node";
                        else classes += " function-node";
                        return classes;
                    })
                    .attr("id", d => `node-${d.id}`)
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .attr("opacity", 0)
                    .on("click", (event, d) => handleNodeClick(event, d))
                    .on("mouseover", (event, d) => showTooltip(event, d))
                    .on("mouseout", () => hideTooltip())
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended));
                
                // Add circles to nodes
                nodeEnter.append("circle")
                    .attr("r", d => {
                        if (d.depth === 0) return 50; // Root node
                        if (d.depth === 1) return 35; // Group nodes
                        return 25; // Function nodes
                    })
                    .attr("fill", d => {
                        if (d.depth === 0) return "#4285F4"; // Root node color
                        if (d.depth === 1) return d.data.color; // Group node color
                        // Function node - lighter shade of parent's color
                        const parentColor = d3.color(d.parent.data.color);
                        parentColor.opacity = 0.8;
                        return parentColor.brighter(0.5);
                    })
                    .attr("stroke", d => {
                        if (d.depth === 0) return "#2956A3"; // Root node stroke
                        if (d.depth === 1) return d3.color(d.data.color).darker(0.5); // Group node stroke
                        return d3.color(d.parent.data.color).darker(0.3); // Function node stroke
                    })
                    .attr("stroke-width", 2);
                
                // Add expand/collapse indicators for group nodes
                nodeEnter.filter(d => d.depth === 1 && d.data.children && d.data.children.length > 0)
                    .append("circle")
                    .attr("class", "expand-icon")
                    .attr("r", 10)
                    .attr("cx", 20)
                    .attr("cy", -20)
                    .attr("fill", "white")
                    .attr("stroke", d => d3.color(d.data.color).darker(0.5))
                    .attr("stroke-width", 1.5);
                
                nodeEnter.filter(d => d.depth === 1 && d.data.children && d.data.children.length > 0)
                    .append("text")
                    .attr("class", "expand-icon-text")
                    .attr("x", 20)
                    .attr("y", -20)
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .attr("fill", d => d3.color(d.data.color).darker(0.5))
                    .text(d => d.data.collapsed ? "+" : "-");
                
                // Add text to nodes
                nodeEnter.append("text")
                    .attr("dy", d => d.depth === 0 ? 0 : ".35em")
                    .text(d => {
                        let name = d.data.name;
                        if (d.depth === 2 && name.length > 15) {
                            return name.substring(0, 13) + "...";
                        }
                        return name;
                    })
                    .style("font-size", d => {
                        if (d.depth === 0) return "18px";
                        if (d.depth === 1) return "14px";
                        return "12px";
                    })
                    .style("font-weight", d => d.depth !== 2 ? "bold" : "normal")
                    .attr("text-anchor", "middle")
                    .attr("fill", d => {
                        if (d.depth === 0) return "white";
                        return "var(--text-color)";
                    });
                
                // For root node, add logo icon
                nodeEnter.filter(d => d.depth === 0)
                    .append("circle")
                    .attr("r", 40)
                    .attr("class", "placeholder-logo")
                    .attr("fill", "#4285F4");
                
                nodeEnter.filter(d => d.depth === 0)
                    .append("text")
                    .attr("class", "placeholder-logo-text")
                    .text("DART")
                    .attr("font-size", "16px");
                
                // Merge nodes and animate
                node = nodeEnter.merge(node)
                    .transition()
                    .duration(300)
                    .attr("opacity", 1);
                
                // Update simulation nodes and links
                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(0.3).restart();
            }
            
            // Process the hierarchy to determine visible nodes
            function processHierarchy(root) {
                nodes = [];
                links = [];
                
                // Always add the root node
                root.each((node, i) => {
                    // Assign unique IDs to nodes if not already present
                    if (!node.id) {
                        node.id = `node-${i}-${node.data.name.replace(/\s+/g, "-").toLowerCase()}`;
                    }
                    
                    // Visible nodes include:
                    // 1. Root node
                    // 2. Group nodes (depth 1)
                    // 3. Function nodes of expanded groups
                    if (node.depth === 0 || node.depth === 1 || 
                       (node.depth === 2 && !node.parent.data.collapsed && !isFiltered(node.parent.data.name))) {
                        nodes.push(node);
                        
                        // Add links between visible nodes and their visible parents
                        if (node.parent && nodes.includes(node.parent)) {
                            links.push({
                                source: node.parent,
                                target: node,
                                value: 1
                            });
                        }
                    }
                });
            }
            
            // Tick function for the force simulation
            function ticked() {
                // Update link paths
                d3.selectAll("path.link")
                    .attr("d", d => {
                        // For links between root and group nodes, use straight lines
                        if (d.source.depth === 0 && d.target.depth === 1) {
                            return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                        }
                        
                        // For other links, use curved paths
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
                        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                    });
                
                // Update node positions
                d3.selectAll("g.node")
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            }
            
            // Handle node click events
            function handleNodeClick(event, d) {
                event.stopPropagation();
                
                if (d.depth === 1 && d.data.children && d.data.children.length > 0) {
                    // Toggle group collapse state
                    d.data.collapsed = !d.data.collapsed;
                    
                    // Update indicator
                    d3.select(event.currentTarget)
                        .select(".expand-icon-text")
                        .text(d.data.collapsed ? "+" : "-");
                    
                    // Update visualization
                    updateVisualization(hierarchyData);
                } else if (d.depth === 2) {
                    // Show function details in sidebar
                    showFunctionDetails(d);
                }
            }
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                // Keep root node fixed
                if (d.depth !== 0) {
                    d.fx = null;
                    d.fy = null;
                }
            }
            
            // Show tooltip with node information
            function showTooltip(event, d) {
                if (d.depth === 0) return; // No tooltip for root node
                
                let tooltipContent = "";
                
                if (d.depth === 1) {
                    // Group node tooltip
                    tooltipContent = `
                        <h3>${d.data.name}</h3>
                        <p>Contains ${d.data.children.length} functions</p>
                        <p><i>Click to ${d.data.collapsed ? "expand" : "collapse"}</i></p>
                    `;
                } else {
                    // Function node tooltip
                    tooltipContent = `
                        <h3>${d.data.name}</h3>
                        <p>Group: ${d.data.group}</p>
                        <p><i>Click for more details</i></p>
                    `;
                }
                
                tooltip.html(tooltipContent)
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY - 28) + "px")
                    .style("opacity", 1);
            }
            
            // Hide tooltip
            function hideTooltip() {
                tooltip.style("opacity", 0);
            }
            
            // Show function details in sidebar
            function showFunctionDetails(d) {
                const functionData = d.data;
                
                const sidebarContent = `
                    <h2 class="function-title">${functionData.name}</h2>
                    <div class="function-group">Group: ${functionData.group}</div>
                    <div class="function-description">${functionData.description}</div>
                    
                    <div class="function-details">
                        <div class="detail-item">
                            <div class="detail-title">Parameters:</div>
                            <div>${functionData.parameters.join(", ")}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-title">Return Type:</div>
                            <div>${functionData.returnType}</div>
                        </div>
                        
                        <div class="detail-item">
                            <div class="detail-title">Example Usage:</div>
                            <div><code>${functionData.example}</code></div>
                        </div>
                    </div>
                `;
                
                d3.select("#sidebar-content").html(sidebarContent);
                sidebar.classed("active", true);
            }
            
            // Initialize search functionality
            function initSearch() {
                const searchInput = d3.select("#search");
                const clearButton = d3.select(".clear-search");
                
                searchInput.on("input", function() {
                    const searchTerm = this.value.toLowerCase().trim();
                    
                    // Show/hide clear button
                    clearButton.style("display", searchTerm ? "block" : "none");
                    
                    // Clear previous timeout
                    if (searchTimeout) clearTimeout(searchTimeout);
                    
                    // Debounce search for better performance
                    searchTimeout = setTimeout(() => performSearch(searchTerm), 300);
                });
                
                clearButton.on("click", function() {
                    searchInput.property("value", "");
                    clearButton.style("display", "none");
                    resetSearch();
                });
            }
            
            // Perform search across nodes
            function performSearch(term) {
                if (!term) {
                    resetSearch();
                    return;
                }
                
                // Reset all node opacities
                d3.selectAll("g.node").attr("opacity", 0.2);
                d3.selectAll("path.link").attr("opacity", 0.2);
                
                // Highlight matching nodes
                d3.selectAll("g.node").each(function(d) {
                    const isMatch = d.data.name.toLowerCase().includes(term);
                    
                    if (isMatch) {
                        // Highlight this node
                        d3.select(this).attr("opacity", 1);
                        
                        // Highlight its parent path
                        let current = d;
                        while (current.parent) {
                            d3.select(`#node-${current.parent.id}`).attr("opacity", 1);
                            
                            // Find and highlight the link
                            d3.selectAll("path.link").filter(link => 
                                link.source === current.parent && link.target === current
                            ).attr("opacity", 1);
                            
                            current = current.parent;
                        }
                        
                        // If it's a group node, ensure it's expanded
                        if (d.depth === 1 && d.data.collapsed) {
                            d.data.collapsed = false;
                            updateVisualization(hierarchyData);
                        }
                    }
                });
            }
            
            // Reset search highlighting
            function resetSearch() {
                d3.selectAll("g.node").attr("opacity", 1);
                d3.selectAll("path.link").attr("opacity", 1);
            }
            
            // Initialize filter options
            function initFilters() {
                const filterContainer = d3.select("#filter-options");
                
                // Get unique function groups
                const groups = Array.from(new Set(parsedData.map(item => item['Function Group'])));
                
                // Create checkboxes for each group
                groups.forEach(group => {
                    const option = filterContainer.append("div")
                        .attr("class", "filter-option");
                    
                    option.append("input")
                        .attr("type", "checkbox")
                        .attr("id", `filter-${group.replace(/\s+/g, "-").toLowerCase()}`)
                        .attr("checked", true)
                        .on("change", function() {
                            // Update active filters
                            if (this.checked) {
                                activeFilters = activeFilters.filter(g => g !== group);
                            } else {
                                activeFilters.push(group);
                            }
                            
                            // Update visualization
                            updateVisualization(hierarchyData);
                        });
                    
                    option.append("label")
                        .attr("for", `filter-${group.replace(/\s+/g, "-").toLowerCase()}`)
                        .text(group);
                });
            }
            
            // Check if a group is filtered out
            function isFiltered(groupName) {
                return activeFilters.includes(groupName);
            }
            
            // Initialize legend
            function initLegend() {
                const legendContainer = d3.select("#legend-items");
                
                // Get unique function groups
                const groups = Object.keys(groupedFunctions);
                
                // Create legend items for each group
                groups.forEach((group, index) => {
                    const item = legendContainer.append("div")
                        .attr("class", "legend-item");
                    
                    item.append("div")
                        .attr("class", "legend-color")
                        .style("background-color", baseColors[index % baseColors.length]);
                    
                    item.append("div")
                        .attr("class", "legend-text")
                        .text(group);
                });
            }
            
            // Initialize dark mode toggle
            function initDarkMode() {
                const toggle = d3.select("#dark-mode-toggle");
                
                // Check user preference
                const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                // Set initial state
                if (prefersDarkMode) {
                    document.body.classList.add("dark-mode");
                    toggle.property("checked", true);
                }
                
                // Toggle dark mode on change
                toggle.on("change", function() {
                    if (this.checked) {
                        document.body.classList.add("dark-mode");
                    } else {
                        document.body.classList.remove("dark-mode");
                    }
                });
            }
            
            // Initialize the visualization when everything is loaded
            window.addEventListener("load", initVisualization);
            
            // Handle window resize
            window.addEventListener("resize", function() {
                width = window.innerWidth;
                height = window.innerHeight;
                
                svg.attr("width", width)
                   .attr("height", height);
                
                // Recenter the visualization
                svg.call(d3.zoom().transform, d3.zoomIdentity.translate(width / 2, height / 2));
                
                // Update simulation
                simulation.force("x", d3.forceX(0).strength(0.05))
                          .force("y", d3.forceY(0).strength(0.05))
                          .restart();
            });
        })();
    </script>
</body>
</html>